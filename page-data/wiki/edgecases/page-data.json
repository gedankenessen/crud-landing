{"componentChunkName":"component---src-templates-wiki-entry-jsx","path":"/wiki/edgecases","result":{"data":{"markdownRemark":{"html":"<br/>\n<p>We've <a href=\"/wiki/first-steps\">previously mentioned</a> that crud cleans the database on <a href=\"/wiki/first-steps#changing\">structure changes</a>. But that isn't the only feature crud provides to improve DX.</p>\n<h2>PUT does not trigger a clean-up</h2>\n<p>When using <code>POST</code> to add data, crud will check if a change to the structure occured. To allow you to play with your data, crud will not check the structure if you do a <code>PUT</code> on an item.</p>\n<br/>\n<p>So if we first <code>POST</code> an item to <code>/products</code></p>\n<pre><code>POST crud.gedankenessen.de/build/products\n{\n  \"name\": \"Keyboard\",\n  \"color\": \"Silver\",\n  \"material\": [\"Metal\", \"Plastic\"]\n}\n</code></pre>\n<p>And then change that item:</p>\n<pre><code>PUT crud.gedankenessen.de/build/products\n{\n  \"name\": \"Keyboard\",\n  \"color\": \"Grey\",\n  \"_id\": \"6392357a6a845062bbc40814\"\n}\n</code></pre>\n<p>No change detection will be run.</p>\n<br/>\n<p>This can be useful if we want to debug or test a specific scenario without clearing our database. For instance, maybe we want to check how our frontend reacts when the array of <code>material</code> is <code>null</code>, instead of just <code>[]</code>.</p>\n<h2>null is treated as a wildcard</h2>\n<p>If you know of a field that will be relevant later but you don't have the data for it yet, you can specify it as <code>null</code> in your <code>POST</code>. This will tell crud not to wipe the database if the field later appears with actual data inside.</p>\n<p>So if we run both of these one after another:</p>\n<pre><code>POST crud.gedankenessen.de/build/products\n{\n  \"name\": \"Keyboard\",\n  \"color\": \"Silver\",\n  \"material\": null\n}\n</code></pre>\n<pre><code>POST crud.gedankenessen.de/build/products\n{\n  \"name\": \"Table\",\n  \"color\": \"Brown\",\n  \"material\": [\"Wood\", \"Metal\"]\n}\n</code></pre>\n<p>A <code>GET</code> will give us both:</p>\n<pre><code>GET crud.gedankenessen.de/build/products\n[\n  {\n    \"name\": \"Keyboard\",\n    \"color\": \"Silver\",\n    \"material\": null,\n    \"_id\": \"6392357a6a845062bbc30183\"\n  },\n  {\n    \"name\": \"Table\",\n    \"color\": \"Brown\",\n    \"material\": [\"Wood\", \"Metal\"],\n    \"_id\": \"6392357a6a845062bbc41924\"\n  },\n]\n</code></pre>\n<h2>Unknown endpoints always return []</h2>\n<p>To minimize headaches <code>GET</code> on undefined or unknown endpoints always return <code>[]</code>. So if we have never done a <code>POST</code> on <code>/tables</code>, the following will just return <code>[]</code>:</p>\n<pre><code>GET crud.gedankenessen.de/build/tables\n[]\n</code></pre>\n<p>This is done so that you don't encounter <code>404</code> errors if you choose to start out by building an overview component (e.g. summary of available tables) first. That way you can build the component that does the <code>POST</code> and defines the structure of your items (e.g. interactive table configurator), later.</p>\n<br/>\n<br/>\n<p><em>Last edited: 2022.12.14; crud:1.1.0</em></p>","frontmatter":{"slug":"edgecases","title":"Edgecases","description":""}}},"pageContext":{"id":"0aa4d581-cd4a-5d78-85dc-a20ee4c60259"}},"staticQueryHashes":["4165905740"]}